### 正则表达式

 - 第一小节
> 正则是一个规则，是用来匹配字`符串的`
> 1、
> 编写一个规则，验证字符串是否符合这个规则，正则匹配使用test方法。
> 2、正则捕获
> 编写一个规则，在一个字符串中把符合规则的内容获取到，正则捕获使用的方法，正则的exec方法、字符串的split方法、字符串的replace方法、match方法等都支持正则。

### 正则的元字符和修饰符
 - 第二小节
 > 任何一个正则都是由 `元字符` 和 `修饰符` 组成的

 `修饰符(img)`
 i(ignoreCase): 忽略大小写匹配
 m(multiline): 多行匹配
 g(global): 全局匹配

 `元字符`
 [量词元字符]
 +： 让元字符出现一次或多次
 ?: 出现零次到一次
 *: 出现零次到多次
 {n}: 出现N次
 {n,}: 出现n到多次
 {n, m}: 出现n 到 m次

 [特殊元字符]
 \: 转译字符（把一个普通的字符转变为有意义的字符 或 把 一个有意义的字符传译为普通字符）
 .: 除\n(换行符)以外的任意字符
 \d: 匹配一个0~9之间的任意数字
 \D: 匹配一个非0~9之间的字符（大写字母和小写字母的组合正好是相反的）
 \w: 匹配一个`0~9或字母或_`之间的字符
 \s: 匹配任意一个空白字符
 \b: 匹配一个边界符
 x|y: 匹配x或y中的一个
 [a-z]: 匹配a-z中的任意一个字符
 [^a-z]: 和上面相反匹配一个非a-z的字符
 [xyz]: 匹配xyz中的一个字符
 [^xyz]: 匹配一个非xyz的字符
 (): 正则的一个小分组，匹配一个小分组（小分组可以理解为大正则中的小正则）
 ^: 以某一元字符开始
 $: 以某一元字符结束
 ?: : 只匹配不捕获
 > 除以上元字符和量词元字符，其余的都叫普通元字符，代表本身意义的元字符

 ```js
  var reg = /^\d+$/; => 这种的是表示 只能是某某某的，这里说明只能是一到多个数字
  reg.test('2') => true // ^ 或者 $ 是一个修饰或者声明，不会占据字符串的位置

  var reg = /^\\d$/;
  > 技巧\\ 其实就代表 \\ 并没有什么意义
 ```

x|y
```js
var reg = /^18|19$/; => 18 19 189 119 819 181 1819 ... 很多都很符合这个规则
/*
* 18 或 19
* 以1开头 以9结尾 中间是8或1的
* 以18开头或以19结尾的即可 => '18珠峰' '珠峰19' 

*/
var reg = /^(18|19)$/; => 此时只有18 或者 19 符合规则
> `()`: 正则中的分组，也可以理解为大正则中的小正则，（包起来的部分是个整体），正则中我们可以使用小括号`改变默认优先级`
> 小分组还有第二个作用： `分组引用`
> 小分组的第三个作用： `分组捕获`

// => 分组引用: \1或\2... 出现和diN个分组一模一样的内容
var reg = /^([a-z])([a-z])\2([a-z])$/; => 符合的字符串有： root, foot, book, week
```

`[]`
```js
> [xyz][^xyz][a-z][^a-z]
// => \w: 数字 字母 下划线中的任意一个字符
var reg = /^[0-9a-zA-Z_]$/; \\ => 等价于 \w
// => 中括号中的元字符，一般代表本身的含义(也就是消磁了)
var reg = /^[.?+&]$/; => 里面的字符都是本身的含义，例如，点就是小数点 不是代表的任意字符

// => 需求： 描述样式类名的规则（数字、字母、下划线、-），并且不能以-开头
//var reg = /^[\w]+$/;
//var reg = /^$[0-9a-zA-Z_]/; // 没有处理以-开头的情况
var reg = /^\w[\w-]*$/;//这个才是正确的 
```

```js
需求：匹配18-65岁年龄的人
var reg = /^((18|19)|([2-5]\d)|(6[0-5]))$/
```